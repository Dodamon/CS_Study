# DEEP DIVE : 데이터베이스의 데드락과 해결방법

## 교착상태(Deadlock)

![Untitled](https://user-images.githubusercontent.com/47595515/211577495-4a7d38fe-d505-470e-8d6e-64ad88856188.png)

- 데이터베이스에서 교착상태는 둘 이상의 트랜잭션이 서로가 잠금을 포기하기를 기다리는 상황

### 교착상태 감지

1. timeout
    - 일정시간(timeout) 이후 트랜잭션이 실행되지 않았을 경우 교착상태로 인식하고 롤백한다
2. 그래프기반으로 사이클 탐색

   ![Untitled 1](https://user-images.githubusercontent.com/47595515/211577503-f289c14e-9df3-4926-b285-efdf5688b792.png)
    
    - 그래프 내에 사이클이 형성되었다라는 것을 기반으로 교착상태를 감지

### 교착상태 방지

- 대규모 데이터베이스의 경우 교착상태를 일일이 감지하는 것은 너무 코스트가 크기 때문에 교착상태 방지를 많이 사용한다
1. 격리수준 변경
    - 교착상태를 방지하기 위해 격리 수준을 조정하는 것
    - serializable이 아닌 이상 모든 교착상태를 제거하는 것은 아니다
2. 서비스의 로직을 교차되지 않게 수정
    - 서비스의 논리 구조를 바꾸는 것
    - 서로 교차되지 않고 일관성 있게 바꾸는 방법
3. Wait-Die 또는 Wound Wait 방법
    - 타임스탬프를 기반으로 트랜잭션을 대기, 선점, 종료하는 방식
    - Wait-Die 방식 : 교착상태 방지를 위한 **비선점기법**
        - 대기하거나 죽거나
        - 오래된 트랜잭션이 요청하면 대기
        - 최신 트랜잭션이 요청하면 죽음
        - ex) 트랜잭션 T5, T10, T15가 각각 타임스탬프 5, 10, 15일 경우
            - T5가 T10이 보유한 데이터 항목을 요청하면 T5는 **대기한다**(Wait)
            - T15가 T10이 보유한 데이터 항목을 요청하면 T15는 **죽는다**(Die)
    - Wound-Wait : 교착상태 방지를 위한 **선점기법**
        - 상처를 입거나 대기하거나
        - 오래된 트랜잭션이 요청하면 데이터를 선점하고 강제로 일시정지
        - 최신 트랜잭션이 요청하면 대기
        - ex) 트랜잭션 T5, T10, T15가 각각 타임스탬프 5, 10, 15일 경우
            - T5가 T10이 보유한 데이터 항목을 요청하면 데이터 항목이 T5에서 선점되고 T10이 **일시 중단**(Wound)
            - T15가 T10이 보유한 데이터 항목을 요청하면 T15는 **대기한다**(Wait)